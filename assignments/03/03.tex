%	
%	solution.tex - Week 3, deadline on 17th of May 2013
%	
%	This document provides answers to the exercises and problems as defined by
%	the course for the week shown below.
%	
%	Mandatory:	15-2
%	Optional:	...
%	Extras:		...
%	

\documentclass[11pt,english]{article}

\usepackage{fancyhdr}
\usepackage{sectsty}
\usepackage{amsmath,amssymb}	% for mathematical notation
\usepackage[linesnumbered]{algorithm2e}

%========== meta data ==========%

\title
{
	\vspace{1in}
	Algorithms \& Datastructures\\
	\huge Assignment 3
}

\author
{
	Casper B. Hansen\\
	\small Department of Computer Science\\
	\small The University of Copenhagen\\
	\texttt{fvx507@alumni.ku.dk}
	\and
	Hans J. T. Stephensen\\
	\small Department of Computer Science\\
	\small The University of Copenhagen\\
	\texttt{xkv467@alumni.ku.dk}
}

\date{\today}


%========== settings ==========%

\setlength{\headheight}{15pt}
\sectionfont{\Large}


%========== macros ==========%

% no macros yet


%========== document ==========%

\begin{document}

\clearpage
\maketitle
\thispagestyle{empty}

%========== mandatory ==========%

\newpage
\pagestyle{fancy}

\section*{Mandatory Hand-ins}

\subsection*{15-2 Longest Palindrome Subsequence}
\large{A palindrome is a nonempty string over some alphabet that reads the
forward and backward. Examples of palindromes are all strings of length 1,
\textit{civic}, \textit{racecar}, and \textit{aibohphobia} (fear of
palindromes).

Give an efficient algorithm to find the longest palindrome that is a
subsequence of a given input string. For example, given the input
\texttt{character}, your algorithm should return \texttt{carac}. What is the
running time of your algorithm?}

\subsubsection*{Algorithm}
We will regard the input sequence $S$ as an object that provides us with a
\texttt{length} method. That is, calling this method on the sequence object
returns the length of the sequence, just as it would if it was an array.

We shall assume that we have access to an \texttt{LCS} procedure, as given in
the CLRS book, pages 394-395, with the minor difference being that we assume
it to return the actual sequence being computed by it, rather than what it
actually does in the books version of the algorithm.

\begin{algorithm}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\SetKwFunction{LCS}{LCS}
	\SetKw{KwDownTo}{down to}
	
	\Input{Takes a sequence $S$ of characters.}
	\Output{The longest palindrome subsequence of the input sequence.}
	\BlankLine
	
	let $R\langle1,\dots,S.length\rangle$ be a new sequence\\ % O(1)
	
	\For{i = 0 \KwTo $S.length - 1$} % O(n)
	{
		$R[S.length - i] = S[i]$
	}
	\Return \LCS(S, R) % O(mn), but m = n, therefore O(n^2)
	
\end{algorithm}

\subsubsection*{Analysis}
On line 1 we spend constant time $\Theta(1)$ creating a new sequence $R$ of
the same length as the input sequence $S$. The following lines 2-4 iterates
over the entire length of the sequence, copying each element from $S$ over
into the new sequence $R$, but in reverse order, this takes $\Theta(n)$ - we
are guaranteed that the \texttt{for}-loop iterates exactly $n$ times, since 
there are no exit conditions within the loop body, justifying the tight bound. As described in the book, the \texttt{LCS} procedure takes $\Theta(mn)$, but
since $R.length = S.length$ then $m = n$ and therefore we spend $\Theta(n^2)$
time on line 5, which also returns the answer.

We therefore have that our algorithm runs a grand total of $T(n) =
\Theta(n^2) + \Theta(n) + \Theta(1) = \Theta(n^2)$. The naive method would be
to compare all subsequences, which would take exponential time, therefore we
claim that our algorithm is "effective" compared to the bruteforce method.

%========== optional ==========%

% no optional hand-ins


%========== extras ==========%

% no extra hand.ins

%========== exercises ==========%

% \newpage
% \pagestyle{fancy}
% \section*{Exercises}
% ...

\end{document}

